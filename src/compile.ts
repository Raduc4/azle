// TODO figure out a good strategy for throwing errors versus returning results

import * as tsc from 'typescript';

type ICFunctionType = 'Query' | 'Update';

type RustType =
    'bool' |
    'String' |
    'i64' |
    'i32' |
    'i16' |
    'i8' |
    'u64' |
    'u32' |
    'u16' |
    'u8' |
    'ic_cdk::export::candid::Nat' |
    'Vec<u8>' |
    'ic_cdk::export::candid::Principal';

type RustProperty = Readonly<{
    name: string;
    type: RustType;
}>;

const rustTypes: {
    [key: string]: RustType | undefined
} = {
    'bool': 'bool',
    'String': 'String',
    'i64': 'i64',
    'i32': 'i32',
    'i16': 'i16',
    'i8': 'i8',
    'u64': 'u64',
    'u32': 'u32',
    'u16': 'u16',
    'u8': 'u8',
    'Nat': 'ic_cdk::export::candid::Nat',
    'ICBlob': 'Vec<u8>',
    'Principal': 'ic_cdk::export::candid::Principal'
};

export function compileJSToRust(
    jsPath: string,
    js: string
): string {
    // TODO for now I am going to use JavaScript/TypeScript to do all of this...consider if it would
    // TODO be more appropriate to use a Rust macro

    const program = tsc.createProgram(
        [jsPath],
        {}
    );
    const sourceFiles = program.getSourceFiles();
    // const sourceFile = tsc.createSourceFile();


        // TODO remove the comments if you can to save space
    // TODO we might want to minify as well to save space

    // TODO we might need to use transpile to get all imports
    const compiledJs = tsc.transpileModule(
        js,
        {
            // compilerOptions: {
            //     module: tsc.ModuleKind.AMD
            // }
        }
    ).outputText;

    const rustCandidTypes = generateRustCandidTypesFromSourceFiles(sourceFiles);

    const rustQueryFunctions = generateRustFunctionsFromSourceFiles(
        sourceFiles,
        compiledJs,
        'Query'
    );

    const rustUpdateFunctions = generateRustFunctionsFromSourceFiles(
        sourceFiles,
        compiledJs,
        'Update'
    );

    // TODO generate all types from TypeScript that are wrapped with Candid

    return `
        // This code is automatically generated by Azle

        thread_local! {
            static IC: std::cell::RefCell<boa::object::JsObject> = std::cell::RefCell::new(boa::object::JsObject::default());
        }

        fn custom_getrandom(_buf: &mut [u8]) -> Result<(), getrandom::Error> { Ok(()) }

        getrandom::register_custom_getrandom!(custom_getrandom);

        #[derive(serde::Deserialize, ic_cdk::export::candid::CandidType)]
        enum Monkey {
            One(String),
            Two(i32)
        }

        #[derive(serde::Deserialize, ic_cdk::export::candid::CandidType)]
        struct Test {
            monkey: Monkey
        }

        ${rustCandidTypes.join('\n')}

        ${rustQueryFunctions.join('\n')}

        ${rustUpdateFunctions.join('\n')}
    `;
}

function generateRustCandidTypesFromSourceFiles(sourceFiles: ReadonlyArray<tsc.SourceFile>): ReadonlyArray<string> {
    const rustCandidTypes = sourceFiles.reduce((result: ReadonlyArray<string>, sourceFile) => {
        return [
            ...result,
            ...generateRustCandidTypesFromNodes(
                sourceFile,
                sourceFile.getChildren()
            )
        ];
    }, []);

    return rustCandidTypes;
}

function generateRustCandidTypesFromNodes(
    sourceFile: tsc.SourceFile,
    nodes: ReadonlyArray<tsc.Node>
): ReadonlyArray<string> {
    if (nodes.length === 0) {
        return [];
    }

    return nodes.reduce((result: ReadonlyArray<string>, node) => {
        const rustCandidType = generateRustCandidTypeFromNode(node);

        return [
            ...result,
            ...(rustCandidType === null ? [] : [rustCandidType]),
            ...generateRustCandidTypesFromNodes(
                sourceFile,
                node.getChildren(sourceFile)
            )
        ];
    }, []);
}

function generateRustCandidTypeFromNode(node: tsc.Node): string | null {
    if (isNodeATypeAliasDeclaration(node) === false) {
        return null;
    }

    const typeAliasDeclaration = node as tsc.TypeAliasDeclaration;
    const typeAliasName = typeAliasDeclaration.name?.escapedText.toString() || 'NO_TYPE_ALIAS_NAME' as string;
    
    if (tsc.isTypeReferenceNode(typeAliasDeclaration.type)) {
        const typeReferenceNode = typeAliasDeclaration.type;

        if (typeReferenceNode.typeArguments?.length === 1) {
            const typeNode = typeReferenceNode.typeArguments[0];

            // TODO split each of these into a separate function
            // TODO split this whole file up into multiple modules
            if (tsc.isTypeLiteralNode(typeNode)) {
                const rustCandidStructFields = getRustCandidStructFields(typeAliasDeclaration);
                const rustCandidStructFieldsString = stringifyRustCandidStructFields(rustCandidStructFields);
            
                return `
                    #[derive(serde::Deserialize, ic_cdk::export::candid::CandidType)]
                    struct ${typeAliasName} {
                        ${rustCandidStructFieldsString}
                    }
                `;
            }

            if (typeNode.kind === tsc.SyntaxKind.StringKeyword) {
                return `type ${typeAliasName} = String;`;
            }

            if (
                tsc.isTypeReferenceNode(typeNode) &&
                tsc.isIdentifier(typeNode.typeName)
            ) {
                if (typeNode.typeName.escapedText === 'Enum') {
                    if (typeNode.typeArguments?.length === 1) {
                        const enumTypeNode = typeNode.typeArguments[0];

                        if (tsc.isTypeLiteralNode(enumTypeNode)) {
                            const typeLiteralNode = enumTypeNode as tsc.TypeLiteralNode;

                            const rustTypes = typeLiteralNode.members.map((member) => {
                                if (tsc.isPropertySignature(member)) {
                                    return {
                                        name: member.name.escapedText,
                                        type: transformTypeNodeToRustType(member.type) // TODO combine this function code with the get function return type code I think
                                    };
                                }
                
                                throw new Error('wrong');
                            });

                            return `
                                #[derive(serde::Deserialize, ic_cdk::export::candid::CandidType)]
                                enum ${typeAliasName} {
                                    ${rustTypes.map((rustType) => {
                                        if (rustType.type === 'None') {
                                            return rustType.name;
                                        }
                                        else {
                                            return `${rustType.name}(${rustType.type})`;
                                        }
                                    }).join(',')}
                                }
                            `;
                        }
                    }
                }
                else if (typeNode.typeName.escapedText === 'Result') {
                    if (typeNode.typeArguments?.length === 2) {
                        return `
                            type ${typeAliasName} = Result<${typeNode.typeArguments[0].typeName.escapedText}, ${typeNode.typeArguments[1].typeName.escapedText}>;
                        `;
                    }
                }
                else {
                    const functionReturnType = rustTypes[typeNode.typeName.escapedText as string];
            
                    if (functionReturnType !== undefined) {
                        return `type ${typeAliasName} = ${functionReturnType};`;
                    }
                    // else {
                    //     // TODO figure this out better
                    //     return typeNode.typeName.escapedText;
                    // }
                }
            }
        }
    }

    throw new Error();
}

function generateRustFunctionsFromSourceFiles(
    sourceFiles: ReadonlyArray<tsc.SourceFile>,
    compiledJs: string,
    icFunctionType: ICFunctionType
): ReadonlyArray<string> {
    const rustFunctions = sourceFiles.reduce((result: ReadonlyArray<string>, sourceFile) => {
        return [
            ...result,
            ...generateRustFunctionsFromNodes(
                sourceFile,
                sourceFile.getChildren(),
                compiledJs,
                icFunctionType
            )
        ];
    }, []);

    return rustFunctions;
}

function generateRustFunctionsFromNodes(
    sourceFile: tsc.SourceFile,
    nodes: ReadonlyArray<tsc.Node>,
    compiledJs: string,
    icFunctionType: ICFunctionType
): ReadonlyArray<string> {
    if (nodes.length === 0) {
        return [];
    }

    return nodes.reduce((result: ReadonlyArray<string>, node) => {
        const rustFunction = generateRustFunctionFromNode(
            node,
            compiledJs,
            icFunctionType
        );

        return [
            ...result,
            ...(rustFunction === null ? [] : [rustFunction]),
            ...generateRustFunctionsFromNodes(
                sourceFile,
                node.getChildren(sourceFile),
                compiledJs,
                icFunctionType
            )
        ];
    }, []);
}

function generateRustFunctionFromNode(
    node: tsc.Node,
    compiledJs: string,
    icFunctionType: ICFunctionType
): string | null {
    if (isNodeAFunctionDeclaration(
        node,
        icFunctionType
    ) === false) {
        return null;
    }

    const functionDeclaration = node as tsc.FunctionDeclaration;
    const functionName = functionDeclaration.name?.escapedText.toString() || 'NO_FUNCTION_NAME' as string;
    const functionReturnType = getFunctionReturnType(
        functionDeclaration,
        icFunctionType
    );
    const functionParameters = getFunctionParameters(functionDeclaration);
    const functionParametersString = stringifyFunctionParameters(functionParameters);

    // TODO these number conversions are horrendous
    const returnValueConversionCode = {
        'bool': 'return_value.parse::<bool>.unwrap()',
        'String': 'return_value',
        'i64': 'return_value.parse::<i64>().unwrap()',
        'i32': 'return_value.parse::<i32>().unwrap()',
        'i16': 'return_value.parse::<i16>().unwrap()',
        'i8': 'return_value.parse::<i8>().unwrap()',
        'u64': 'return_value.parse::<u64>().unwrap()',
        'u32': 'return_value.parse::<u32>().unwrap()',
        'u16': 'return_value.parse::<u16>().unwrap()',
        'u8': 'return_value.parse::<u8>().unwrap()',
        'ic_cdk::export::candid::Nat': 'return_value.parse::<ic_cdk::export::candid::Nat>().unwrap()',
        'Vec<u8>': 'return_value.parse::<Vec<u8>>.unwrap()', // TODO have not tested this
        'ic_cdk::export::candid::Principal': 'return_value.parse::<ic_cdk::export::candid::Principal>().unwrap()'
    }[functionReturnType] ?? `serde_json::from_str::<${functionReturnType}>(&return_value).unwrap()`;

    // TODO serde_json::from_str(boa::builtins::json::stringify(return_value)) as TransferRequest

    if (icFunctionType === 'Query') {
        return generateRustQueryFunction(
            functionName,
            functionParametersString,
            functionReturnType,
            functionParameters,
            compiledJs,
            returnValueConversionCode
        );
    }
    
    if (icFunctionType === 'Update') {
        return generateRustUpdateFunction(
            functionName,
            functionParametersString,
            functionReturnType,
            functionParameters,
            compiledJs,
            returnValueConversionCode
        );
    }

    return null;
}

function generateRustQueryFunction(
    functionName: string,
    functionParametersString: string,
    functionReturnType: RustType,
    functionParameters: ReadonlyArray<RustProperty>,
    compiledJs: string,
    returnValueConversionCode: string
): string {
// TODO Figure out a more elegant way to define the exports object than the string replace below
    return `
        #[ic_cdk_macros::query]
        fn ${functionName}(${functionParametersString}) -> ${functionReturnType} {
            IC.with(|ic_ref_cell| {
                let ic = ic_ref_cell.borrow().clone();
                
                let mut context = boa::Context::new();

                context.register_global_property(
                    "ic",
                    ic,
                    boa::property::Attribute::all()
                );
            
                let return_value = context.eval(format!(
                    "
                        {compiled_js}
    
                        JSON.stringify(${functionName}(${functionParameters.map((functionParameter) => {
                            if (functionParameter.type === 'String') {
                                return `\\"{${functionParameter.name}}\\"`;
                            }
    
                            return `{${functionParameter.name}}`;
                        }).join(',')}));
                    ",
                    compiled_js = r#"${compiledJs}"#,
                    ${functionParameters.map((functionParameter) => {
                        return `${functionParameter.name} = ${functionParameter.name}`;
                    }).join(',')}
                ).replace("Object.defineProperty", "let exports = {}; Object.defineProperty")).unwrap().as_string().unwrap().to_string();
                                
                ${returnValueConversionCode}
            })
        }
    `;
}

function generateRustUpdateFunction(
    functionName: string,
    functionParametersString: string,
    functionReturnType: RustType,
    functionParameters: ReadonlyArray<RustProperty>,
    compiledJs: string,
    returnValueConversionCode: string
): string {
// TODO Figure out a more elegant way to define the exports object than the string replace below
    return `
        #[ic_cdk_macros::update]
        fn ${functionName}(${functionParametersString}) -> ${functionReturnType} {
            IC.with(|ic_ref_cell| {
                let ic = ic_ref_cell.borrow().clone();

                let mut context = boa::Context::new();
            
                context.register_global_property(
                    "ic",
                    ic,
                    boa::property::Attribute::all()
                );

                let return_value = context.eval(format!(
                    "
                        {compiled_js}
    
                        ${functionName}(${functionParameters.map((functionParameter) => {
                            if (functionParameter.type === 'String') {
                                return `\\"{${functionParameter.name}}\\"`;
                            }
    
                            return `{${functionParameter.name}}`;
                        }).join(',')});
                    ",
                    compiled_js = r#"${compiledJs}"#,
                    ${functionParameters.map((functionParameter) => {
                        return `${functionParameter.name} = ${functionParameter.name}`;
                    }).join(',')}
                ).replace("Object.defineProperty", "let exports = {}; Object.defineProperty")).unwrap().as_string().unwrap().to_string();
            
                let ic = context
                    .global_object()
                    .get(
                        "ic",
                        &mut context
                    )
                    .unwrap()
                    .as_object()
                    .unwrap()
                    .clone();
        
                ic_ref_cell.replace(ic);
    
                ${returnValueConversionCode}
            })
        }
    `;
}

function isNodeATypeAliasDeclaration(node: tsc.Node): boolean {
    if (tsc.isTypeAliasDeclaration(node) === false) {
        return false;
    }

    const typeAliasDeclaration = node as tsc.TypeAliasDeclaration;

    if (typeAliasDeclaration.type === undefined) {
        return false;
    }

    if (tsc.isTypeReferenceNode(typeAliasDeclaration.type) === false) {
        return false;
    }

    const typeReferenceNode = typeAliasDeclaration.type as tsc.TypeReferenceNode;

    if (tsc.isIdentifier(typeReferenceNode.typeName) === false) {
        return false;
    }

    const identifier = typeReferenceNode.typeName as tsc.Identifier;

    if (identifier.escapedText !== 'Candid') {
        return false;
    }

    return true;
}

function isNodeAFunctionDeclaration(
    node: tsc.Node,
    icFunctionType: ICFunctionType
): boolean {
    if (tsc.isFunctionDeclaration(node) === false) {
        return false;
    }

    const functionDeclaration = node as tsc.FunctionDeclaration;

    if (functionDeclaration.type === undefined) {
        return false;
    }

    if (tsc.isTypeReferenceNode(functionDeclaration.type) === false) {
        return false;
    }

    const typeReferenceNode = functionDeclaration.type as tsc.TypeReferenceNode;

    if (tsc.isIdentifier(typeReferenceNode.typeName) === false) {
        return false;
    }

    const identifier = typeReferenceNode.typeName as tsc.Identifier;

    if (identifier.escapedText !== icFunctionType) {
        return false;
    }

    return true;
}

function getFunctionReturnType(
    functionDeclaration: tsc.FunctionDeclaration,
    icFunctionType: ICFunctionType
): RustType {
    const functionName = functionDeclaration.name?.escapedText;

    if (functionDeclaration.type === undefined) {
        throw new Error(`Azle::compile::getFunctionReturnType: TypeScript query function ${functionName} must have a return type`);
    }

    // TODO this might be repeat code
    if (tsc.isTypeReferenceNode(functionDeclaration.type)) {
        const typeReferenceNode = functionDeclaration.type as tsc.TypeReferenceNode;
        
        if (
            tsc.isIdentifier(typeReferenceNode.typeName) &&
            typeReferenceNode.typeName.escapedText === icFunctionType &&
            typeReferenceNode.typeArguments !== undefined &&
            typeReferenceNode.typeArguments.length === 1
        ) {
            const typeArgument = typeReferenceNode.typeArguments[0];

            if (typeArgument.kind === tsc.SyntaxKind.StringKeyword) {
                return 'String';
            }
        
            if (typeArgument.kind === tsc.SyntaxKind.BooleanKeyword) {
                return 'bool';
            }

            if (
                tsc.isTypeReferenceNode(typeArgument) &&
                tsc.isIdentifier(typeArgument.typeName)
            ) {
                const functionReturnType = rustTypes[typeArgument.typeName.escapedText as string];
        
                if (functionReturnType !== undefined) {
                    return functionReturnType;
                }
                else {
                    // TODO figure this out better
                    return typeArgument.typeName.escapedText;
                }
            }

            console.log('typeArgument', typeArgument);
        }
    }

    throw new Error(`Azle::compile::getFunctionReturnType: TypeScript query function ${functionName} return type not supported`);
}

function getRustCandidStructFields(typeAliasDeclaration: tsc.TypeAliasDeclaration): ReadonlyArray<RustProperty> {
    if (tsc.isTypeReferenceNode(typeAliasDeclaration.type)) {
        const typeReferenceNode = typeAliasDeclaration.type;

        if(
            typeReferenceNode.typeArguments?.length === 1 &&
            tsc.isTypeLiteralNode(typeReferenceNode.typeArguments[0])
        ) {
            const typeLiteralNode = typeReferenceNode.typeArguments[0];

            return typeLiteralNode.members.map((member) => {
                if (tsc.isPropertySignature(member)) {
                    return {
                        name: member.name.escapedText,
                        type: transformTypeNodeToRustType(member.type) // TODO combine this function code with the get function return type code I think
                    };
                }

                throw new Error('wrong');
            });
        }
    }
    
    return [];
}

function stringifyRustCandidStructFields(rustCandidStructFields: ReadonlyArray<RustProperty>): string {
    return rustCandidStructFields.map((rustCandidStructField) => {
        return `${rustCandidStructField.name}: ${rustCandidStructField.type}`;
    }).join(', ');
}

function getFunctionParameters(functionDeclaration: tsc.FunctionDeclaration): ReadonlyArray<RustProperty> {
    return functionDeclaration.parameters.map((parameter) => {
        if (
            tsc.isIdentifier(parameter.name) &&
            parameter.type !== undefined
            // &&
            // tsc.isTypeReferenceNode(parameter.type)
        ) {
            const parameterName = parameter.name.escapedText.toString();
            // const rustType = transformTypeReferenceNodeToRustType(parameter.type);
            const rustType = transformTypeNodeToRustType(parameter.type);
            
            return {
                name: parameterName,
                type: rustType
            };
        }
        
        throw new Error();
    });
}

function stringifyFunctionParameters(functionParameters: ReadonlyArray<RustProperty>): string {
    return functionParameters.map((functionParameter) => {
        return `${functionParameter.name}: ${functionParameter.type}`;
    }).join(', ');
}

// TODO here is where I think we want to follow aliases
function transformTypeNodeToRustType(typeNode: tsc.TypeNode): RustType {
    if (typeNode.kind === tsc.SyntaxKind.StringKeyword) {
        return 'String';
    }

    if (typeNode.kind === tsc.SyntaxKind.BooleanKeyword) {
        return 'bool';
    }

    if (
        tsc.isLiteralTypeNode(typeNode) &&
        typeNode.literal.kind === tsc.SyntaxKind.NullKeyword
    ) {
        return 'None';
    }

    if (
        tsc.isTypeReferenceNode(typeNode) &&
        tsc.isIdentifier(typeNode.typeName)
    ) {
        const rustType = rustTypes[typeNode.typeName.escapedText as string];

        if (rustType !== undefined) {
            return rustType;
        }
        else {
            return typeNode.typeName.escapedText;
        }
    }

    throw new Error('TypeScript type not supported');
}