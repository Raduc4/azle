// TODO figure out a good strategy for throwing errors versus returning results

import * as tsc from 'typescript';

type ICFunctionType = 'Query' | 'Update';

type RustType =
    'bool' |
    'String' |
    'i64' |
    'i32' |
    'i16' |
    'i8' |
    'u128' |
    'u64' |
    'u32' |
    'u16' |
    'u8' |
    // 'ic_cdk::export::candid::Nat' | // TODO replaced with u128 for now
    'Vec<u8>' |
    'ic_cdk::export::candid::Principal';

type RustProperty = Readonly<{
    name: string;
    type: RustType;
}>;

const rustTypes: {
    [key: string]: RustType | undefined
} = {
    'bool': 'bool',
    'String': 'String',
    'i64': 'i64',
    'i32': 'i32',
    'i16': 'i16',
    'i8': 'i8',
    'u64': 'u64',
    'u32': 'u32',
    'u16': 'u16',
    'u8': 'u8',
    // 'Nat': 'ic_cdk::export::candid::Nat', // TODO replaced with u128 for now
    'Nat': 'u128', // TODO replaced with u128 for now
    'ICBlob': 'Vec<u8>',
    'Principal': 'ic_cdk::export::candid::Principal'
};

export function compileJSToRust(
    tsPath: string,
    js: string
): string {
    // TODO for now I am going to use JavaScript/TypeScript to do all of this...consider if it would
    // TODO be more appropriate to use a Rust macro

    const program = tsc.createProgram(
        [tsPath],
        {}
    );
    const sourceFiles = program.getSourceFiles();
    // const sourceFile = tsc.createSourceFile();


        // TODO remove the comments if you can to save space
    // TODO we might want to minify as well to save space

    // TODO we might need to use transpile to get all imports

    const rustCandidTypes = generateRustCandidTypesFromSourceFiles(sourceFiles);

    const rustQueryFunctions = generateRustFunctionsFromSourceFiles(
        sourceFiles,
        js,
        'Query'
    );

    const rustUpdateFunctions = generateRustFunctionsFromSourceFiles(
        sourceFiles,
        js,
        'Update'
    );

    // TODO generate all types from TypeScript that are wrapped with Candid

    return `
        // This code is automatically generated by Azle

        #![allow(dead_code)]
        #![allow(non_camel_case_types)]
        #![allow(non_snake_case)]

        thread_local! {
            static BOA_CONTEXT: std::cell::RefCell<boa_engine::Context> = std::cell::RefCell::new(boa_engine::Context::default());
        }

        fn custom_getrandom(_buf: &mut [u8]) -> Result<(), getrandom::Error> { Ok(()) }

        getrandom::register_custom_getrandom!(custom_getrandom);

        #[ic_cdk_macros::init]
        fn init() {
            BOA_CONTEXT.with(|boa_context_ref_cell| {
                let mut boa_context = boa_context_ref_cell.borrow_mut();

                let ic = boa_engine::object::ObjectInitializer::new(&mut boa_context)
                    // .property(
                    //     "caller",
                    //     ic_cdk::api::caller().to_text(),
                    //     boa_engine::property::Attribute::all()
                    // )
                    // .property(
                    //     "print",
                    //     ic_print,
                    //     boa_engine::property::Attribute::all()
                    // )
                    .function(
                        ic_caller,
                        "caller",
                        0
                    )
                    .function(
                        ic_print,
                        "print",
                        0
                    )
                    .function(
                        ic_id,
                        "id",
                        0
                    )
                    .function(
                        ic_canister_balance,
                        "canisterBalance",
                        0
                    )
                    .function(
                        ic_time,
                        "time",
                        0
                    )
                    .function(
                        ic_trap,
                        "trap",
                        0
                    )
                    .function(
                        ic_raw_rand,
                        "rawRand",
                        0
                    )
                    .function(
                        ic_test_cross_canister,
                        "testCrossCanister",
                        0
                    )
                    .build();

                boa_context.register_global_property(
                    "ic",
                    ic,
                    boa_engine::property::Attribute::all()
                );

                // boa_context.register_global_function(
                //     "icPrint",
                //     0,
                //     ic_print
                // ).unwrap();

                boa_context.eval(format!(
                    "let exports = {{}}; {compiled_js}",
                    compiled_js = r#"${js}"#
                )).unwrap();
            });
        }

        #[ic_cdk_macros::post_upgrade]
        fn post_upgrade() {
            init();
        }

        ${rustCandidTypes.join('\n')}

        ${rustQueryFunctions.join('\n')}

        ${rustUpdateFunctions.join('\n')}

        fn ic_print(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            ic_cdk::println!("{:#?}", _aargs);
        
            return Ok(boa_engine::JsValue::Undefined);
        }

        fn ic_caller(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            return Ok(
                boa_engine::JsValue::String(
                    boa_engine::JsString::new(
                        ic_cdk::api::caller().to_text()
                    )
                )
            );
        }

        fn ic_id(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            return Ok(
                boa_engine::JsValue::String(
                    boa_engine::JsString::new(
                        ic_cdk::api::id().to_text()
                    )
                )
            );
        }

        fn ic_canister_balance(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            return Ok(
                boa_engine::JsValue::Rational(
                    ic_cdk::api::canister_balance() as f64 // TODO this conversion is probably not safe
                )
            );
        }

        fn ic_time(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            return Ok(
                boa_engine::JsValue::Rational(
                    ic_cdk::api::time() as f64 // TODO this conversion is probably not safe
                )
            );
        }

        fn ic_trap(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            ic_cdk::api::trap(_aargs.get(0).unwrap().as_string().unwrap());
        }

        fn ic_raw_rand(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            // let mut context = boa_engine::Context::new();

            // let raw_rand = futures::executor::block_on(async {
            //     let call_result: Result<(Vec<u8>,), _> = ic_cdk::api::call::call(
            //         ic_cdk::export::Principal::management_canister(),
            //         "raw_rand",
            //         ()
            //     ).await;

            //     return call_result.unwrap().0;
            // });

            // let value = context
            //     .eval(
            //         format!(
            //             "Uint8Array.from({raw_rand})",
            //             raw_rand = serde_json::to_string(&raw_rand).unwrap()
            //         )
            //     )
            //     .unwrap();

            // return Ok(value);

            // TODO we should be able to provide randomness without cross-canister calls
            Ok(boa_engine::JsValue::Undefined)
        }

        fn ic_test_cross_canister(
            _this: &boa_engine::JsValue,
            _aargs: &[boa_engine::JsValue],
            _context: &mut boa_engine::Context
        ) -> boa_engine::JsResult<boa_engine::JsValue> {
            // std::thread::sleep(std::time::Duration::new(5,0 ));

            // TODO what I am considering next is using LocalPool from futures
            // TODO maybe I can just manually create a local executor and get this all to work

            // let mut context = boa_engine::Context::new();

            // let string = futures::executor::block_on(async {
            //     let call_result: Result<(String,), _> = ic_cdk::api::call::call(
            //         ic_cdk::export::Principal::from_text("ryjl3-tyaaa-aaaaa-aaaba-cai").unwrap(),
            //         "testString",
            //         ()
            //     ).await;

            //     return call_result.unwrap().0;
            // });

            // let value = context
            //     .eval(
            //         format!(
            //             "{string}",
            //             string = serde_json::to_string(&string).unwrap()
            //         )
            //     )
            //     .unwrap();

            // return Ok(value);

            // let result = ic_cdk::block_on_with_output(async {
            //     let call_result: Result<(String,), _> = ic_cdk::api::call::call(
            //         ic_cdk::export::Principal::from_text("ryjl3-tyaaa-aaaaa-aaaba-cai").unwrap(),
            //         "testString",
            //         ()
            //     ).await;

            //     let string = call_result.unwrap().0;

            //     ic_cdk::println!("string: {}", string);

            //     return string;
            // });

            // ic_cdk::println!("0");

            // ic_cdk::block_on(async {
            //     let call_result: Result<(String,), _> = ic_cdk::api::call::call(
            //         ic_cdk::export::Principal::from_text("ryjl3-tyaaa-aaaaa-aaaba-cai").unwrap(),
            //         "testString",
            //         ()
            //     ).await;

            //     let string = call_result.unwrap().0;

            //     ic_cdk::println!("string: {}", string);

            //     CROSS_CANISTER_RESULT.with(|cross_canister_result_ref_cell| {
            //         cross_canister_result_ref_cell.replace("hello".to_string());
            //         // cross_canister_result_ref_cell.replace(string);
            //     });
            // });

            // ic_cdk::println!("1");

            // CROSS_CANISTER_RESULT.with(|cross_canister_result_ref_cell| {
            //     let cross_canister_result = cross_canister_result_ref_cell.borrow();

            //     ic_cdk::println!("cross_canister_result: {:#?}", cross_canister_result);
            // });

            // ic_cdk::println!("2");

            // ic_cdk::println!("result: {:#?}", result);

            // let simple_cross_canister_future: std::future::Future<Output = Result<(String,), _>> = ic_cdk::api::call::call(
            //     ic_cdk::export::Principal::from_text("ryjl3-tyaaa-aaaaa-aaaba-cai").unwrap(),
            //     "testString",
            //     ()
            // );

            // let cross_canister_future = async {
            //     let call_result: Result<(String,), _> = ic_cdk::api::call::call(
            //         ic_cdk::export::Principal::from_text("ryjl3-tyaaa-aaaaa-aaaba-cai").unwrap(),
            //         "testString",
            //         ()
            //     ).await;

            //     let string = call_result.unwrap().0;

            //     ic_cdk::println!("string: {}", string);

            //     return string;
            // };

            // let simple_future = async {
            //     String::from("It worked")
            // };

            // let mut pool = futures::executor::LocalPool::new();
            // let spawner = pool.spawner();

            // spawner.spawn_local_obj(Box::new(future));

            // let result = pool.run_until(future);

            // let result = futures::executor::block_on(cross_canister_future);

            // let result = wasm_rs_async_executor::single_threaded::block_on(cross_canister_future);
            // let result = wasm_rs_async_executor::single_threaded::block_on(simple_future);

            // ic_cdk::println!("result: {:#?}", result);

            return Ok(boa_engine::JsValue::Undefined);
        }

        ic_cdk::export::candid::export_service!();

        #[ic_cdk_macros::query]
        fn __get_candid_interface_tmp_hack() -> String {
            __export_service()
        }
    `;
}

function generateRustCandidTypesFromSourceFiles(sourceFiles: ReadonlyArray<tsc.SourceFile>): ReadonlyArray<string> {
    const rustCandidTypes = sourceFiles.reduce((result: ReadonlyArray<string>, sourceFile) => {
        return [
            ...result,
            ...generateRustCandidTypesFromNodes(
                sourceFile,
                sourceFile.getChildren()
            )
        ];
    }, []);

    return rustCandidTypes;
}

function generateRustCandidTypesFromNodes(
    sourceFile: tsc.SourceFile,
    nodes: ReadonlyArray<tsc.Node>
): ReadonlyArray<string> {
    if (nodes.length === 0) {
        return [];
    }

    return nodes.reduce((result: ReadonlyArray<string>, node) => {
        const rustCandidType = generateRustCandidTypeFromNode(node);

        return [
            ...result,
            ...(rustCandidType === null ? [] : [rustCandidType]),
            ...generateRustCandidTypesFromNodes(
                sourceFile,
                node.getChildren(sourceFile)
            )
        ];
    }, []);
}

function generateRustCandidTypeFromNode(node: tsc.Node): string | null {
    if (isNodeATypeAliasDeclaration(node) === false) {
        return null;
    }

    const typeAliasDeclaration = node as tsc.TypeAliasDeclaration;
    const typeAliasName = typeAliasDeclaration.name?.escapedText.toString() || 'NO_TYPE_ALIAS_NAME' as string;
    
    if (tsc.isTypeReferenceNode(typeAliasDeclaration.type)) {
        const typeReferenceNode = typeAliasDeclaration.type;

        if (typeReferenceNode.typeArguments?.length === 1) {
            const typeNode = typeReferenceNode.typeArguments[0];

            // TODO split each of these into a separate function
            // TODO split this whole file up into multiple modules
            if (tsc.isTypeLiteralNode(typeNode)) {
                const rustCandidStructFields = getRustCandidStructFields(typeAliasDeclaration);
                const rustCandidStructFieldsString = stringifyRustCandidStructFields(rustCandidStructFields);
            
                return `
                    #[derive(serde::Serialize, serde::Deserialize, ic_cdk::export::candid::CandidType)]
                    struct ${typeAliasName} {
                        ${rustCandidStructFieldsString}
                    }
                `;
            }

            if (typeNode.kind === tsc.SyntaxKind.StringKeyword) {
                return `type ${typeAliasName} = String;`;
            }

            if (tsc.isTupleTypeNode(typeNode)) {
                return `
                    #[derive(serde::Serialize, serde::Deserialize, ic_cdk::export::candid::CandidType)]
                    struct ${typeAliasName}(${typeNode.elements.map((element) => element.typeName.escapedText).join(',')});
                `;
            }

            if (
                tsc.isTypeReferenceNode(typeNode) &&
                tsc.isIdentifier(typeNode.typeName)
            ) {
                if (typeNode.typeName.escapedText === 'Enum') {
                    if (typeNode.typeArguments?.length === 1) {
                        const enumTypeNode = typeNode.typeArguments[0];

                        if (tsc.isTypeLiteralNode(enumTypeNode)) {
                            const typeLiteralNode = enumTypeNode as tsc.TypeLiteralNode;

                            const rustTypes = typeLiteralNode.members.map((member) => {
                                if (tsc.isPropertySignature(member)) {
                                    return {
                                        name: member.name.escapedText,
                                        type: transformTypeNodeToRustType(member.type) // TODO combine this function code with the get function return type code I think
                                    };
                                }
                
                                throw new Error('wrong');
                            });

                            return `
                                #[derive(serde::Serialize, serde::Deserialize, ic_cdk::export::candid::CandidType)]
                                enum ${typeAliasName} {
                                    ${rustTypes.map((rustType) => {
                                        if (rustType.type === 'None') {
                                            return rustType.name;
                                        }
                                        else {
                                            return `${rustType.name}(${rustType.type})`;
                                        }
                                    }).join(',')}
                                }
                            `;
                        }
                    }
                }
                else if (typeNode.typeName.escapedText === 'Result') {
                    if (typeNode.typeArguments?.length === 2) {
                        return `
                            // type ${typeAliasName} = Result<${typeNode.typeArguments[0].typeName.escapedText}, ${typeNode.typeArguments[1].typeName.escapedText}>;
                        
                            #[derive(serde::Serialize, serde::Deserialize, ic_cdk::export::candid::CandidType)]
                            enum ${typeAliasName} {
                                ok(${typeNode.typeArguments[0].typeName.escapedText}),
                                err(${typeNode.typeArguments[1].typeName.escapedText})
                            }
                        `;
                    }
                }
                else {
                    const functionReturnType = rustTypes[typeNode.typeName.escapedText as string];
            
                    if (functionReturnType !== undefined) {
                        return `type ${typeAliasName} = ${functionReturnType};`;
                    }
                    // else {
                    //     // TODO figure this out better
                    //     return typeNode.typeName.escapedText;
                    // }
                }
            }

            if (tsc.isArrayTypeNode(typeNode)) {
                if (typeNode.elementType.kind === tsc.SyntaxKind.StringKeyword) {
                    return `Vec<String>`;
                }
        
                if (
                    tsc.isTypeReferenceNode(typeNode.elementType) &&
                    tsc.isIdentifier(typeNode.elementType.typeName)
                ) {
                    return `type ${typeAliasName} = Vec<${typeNode.elementType.typeName.escapedText}>;`;
                }
            }
        }
    }

    throw new Error();
}

function generateRustFunctionsFromSourceFiles(
    sourceFiles: ReadonlyArray<tsc.SourceFile>,
    compiledJs: string,
    icFunctionType: ICFunctionType
): ReadonlyArray<string> {
    const rustFunctions = sourceFiles.reduce((result: ReadonlyArray<string>, sourceFile) => {
        return [
            ...result,
            ...generateRustFunctionsFromNodes(
                sourceFile,
                sourceFile.getChildren(),
                compiledJs,
                icFunctionType
            )
        ];
    }, []);

    return rustFunctions;
}

function generateRustFunctionsFromNodes(
    sourceFile: tsc.SourceFile,
    nodes: ReadonlyArray<tsc.Node>,
    compiledJs: string,
    icFunctionType: ICFunctionType
): ReadonlyArray<string> {
    if (nodes.length === 0) {
        return [];
    }

    return nodes.reduce((result: ReadonlyArray<string>, node) => {
        const rustFunction = generateRustFunctionFromNode(
            node,
            compiledJs,
            icFunctionType
        );

        return [
            ...result,
            ...(rustFunction === null ? [] : [rustFunction]),
            ...generateRustFunctionsFromNodes(
                sourceFile,
                node.getChildren(sourceFile),
                compiledJs,
                icFunctionType
            )
        ];
    }, []);
}

function generateRustFunctionFromNode(
    node: tsc.Node,
    compiledJs: string,
    icFunctionType: ICFunctionType
): string | null {
    if (isNodeAFunctionDeclaration(
        node,
        icFunctionType
    ) === false) {
        return null;
    }

    const functionDeclaration = node as tsc.FunctionDeclaration;
    const functionName = functionDeclaration.name?.escapedText.toString() || 'NO_FUNCTION_NAME' as string;
    const functionReturnType = getFunctionReturnType(
        functionDeclaration,
        icFunctionType
    );
    const functionParameters = getFunctionParameters(functionDeclaration);
    const functionParametersString = stringifyFunctionParameters(functionParameters);

    // TODO these number conversions are horrendous
    const returnValueConversionCode = {
        'bool': 'serde_json::from_str(&return_value).unwrap()',
        'String': 'return_value',
        'i64': 'return_value.parse::<i64>().unwrap()',
        'i32': 'return_value.parse::<i32>().unwrap()',
        'i16': 'return_value.parse::<i16>().unwrap()',
        'i8': 'return_value.parse::<i8>().unwrap()',
        'u128': 'return_value.parse::<u128>().unwrap()',
        'u64': 'return_value.parse::<u64>().unwrap()',
        'u32': 'return_value.parse::<u32>().unwrap()',
        'u16': 'return_value.parse::<u16>().unwrap()',
        'u8': 'return_value.parse::<u8>().unwrap()',
        // 'ic_cdk::export::candid::Nat': 'return_value.parse::<ic_cdk::export::candid::Nat>().unwrap()',
        'Vec<u8>': 'return_value.parse::<Vec<u8>>.unwrap()', // TODO have not tested this
        'ic_cdk::export::candid::Principal': 'return_value.parse::<ic_cdk::export::candid::Principal>().unwrap()'
    }[functionReturnType] ?? `serde_json::from_str::<${functionReturnType}>(&return_value).unwrap()`;

    // TODO serde_json::from_str(boa_engine::builtins::json::stringify(return_value)) as TransferRequest

    if (icFunctionType === 'Query') {
        return generateRustFunction(
            'QUERY',
            functionName,
            functionParametersString,
            functionReturnType,
            functionParameters,
            compiledJs,
            returnValueConversionCode
        );
    }
    
    if (icFunctionType === 'Update') {
        return generateRustFunction(
            'UPDATE',
            functionName,
            functionParametersString,
            functionReturnType,
            functionParameters,
            compiledJs,
            returnValueConversionCode
        );
    }

    return null;
}

// TODO ensure values are cleanly sanitized
function generateRustFunction(
    queryOrUpdate: 'QUERY' | 'UPDATE',
    functionName: string,
    functionParametersString: string,
    functionReturnType: RustType,
    functionParameters: ReadonlyArray<RustProperty>,
    compiledJs: string,
    returnValueConversionCode: string
): string {
    return `
        #[ic_cdk_macros::${queryOrUpdate === 'QUERY' ? 'query' : 'update'}]
        #[ic_cdk::export::candid::candid_method(${queryOrUpdate === 'QUERY' ? 'query' : 'update'})]
        async fn ${functionName}(${functionParametersString}) -> ${functionReturnType} {
            // let string = futures::executor::block_on(async {
            //     let call_result: Result<(String,), _> = ic_cdk::api::call::call(
            //         ic_cdk::export::Principal::from_text("ryjl3-tyaaa-aaaaa-aaaba-cai").unwrap(),
            //         "testString",
            //         ()
            //     ).await;

            //     return call_result.unwrap().0;
            // });

            // ic_cdk::println!("string: {}", string);

            // ic_cdk::block_on(async {
            //     let call_result: Result<(String,), _> = ic_cdk::api::call::call(
            //         ic_cdk::export::Principal::from_text("ryjl3-tyaaa-aaaaa-aaaba-cai").unwrap(),
            //         "testString",
            //         ()
            //     ).await;

            //     let string = call_result.unwrap().0;

            //     ic_cdk::println!("string: {}", string);
            // });

            BOA_CONTEXT.with(|boa_context_ref_cell| {
                let mut boa_context = boa_context_ref_cell.borrow_mut();

                // TODO grab the error message from the return value and panic on it if possible, the errors are almost unreadable
                let return_value = boa_context.eval(format!(
                    "
                        JSON.stringify(${functionName}(${functionParameters.map((functionParameter) => {
                            return `{${functionParameter.name}}`;
                        }).join(',')}));
                    ",
                    ${functionParameters.map((functionParameter) => {
                        return `${functionParameter.name} = serde_json::to_string(&${functionParameter.name}).unwrap()`;
                    }).join(',')}
                ))
                .unwrap()
                .as_string()
                .unwrap()
                .to_string();

                ${returnValueConversionCode}
            })
        }
    `;
}

function isNodeATypeAliasDeclaration(node: tsc.Node): boolean {
    if (tsc.isTypeAliasDeclaration(node) === false) {
        return false;
    }

    const typeAliasDeclaration = node as tsc.TypeAliasDeclaration;

    if (typeAliasDeclaration.type === undefined) {
        return false;
    }

    if (tsc.isTypeReferenceNode(typeAliasDeclaration.type) === false) {
        return false;
    }

    const typeReferenceNode = typeAliasDeclaration.type as tsc.TypeReferenceNode;

    if (tsc.isIdentifier(typeReferenceNode.typeName) === false) {
        return false;
    }

    const identifier = typeReferenceNode.typeName as tsc.Identifier;

    if (identifier.escapedText !== 'Candid') {
        return false;
    }

    return true;
}

function isNodeAFunctionDeclaration(
    node: tsc.Node,
    icFunctionType: ICFunctionType
): boolean {
    if (tsc.isFunctionDeclaration(node) === false) {
        return false;
    }

    const functionDeclaration = node as tsc.FunctionDeclaration;

    if (functionDeclaration.type === undefined) {
        return false;
    }

    if (tsc.isTypeReferenceNode(functionDeclaration.type) === false) {
        return false;
    }

    const typeReferenceNode = functionDeclaration.type as tsc.TypeReferenceNode;

    if (tsc.isIdentifier(typeReferenceNode.typeName) === false) {
        return false;
    }

    const identifier = typeReferenceNode.typeName as tsc.Identifier;

    if (identifier.escapedText !== icFunctionType) {
        return false;
    }

    return true;
}

function getFunctionReturnType(
    functionDeclaration: tsc.FunctionDeclaration,
    icFunctionType: ICFunctionType
): RustType {
    const functionName = functionDeclaration.name?.escapedText;

    if (functionDeclaration.type === undefined) {
        throw new Error(`Azle::compile::getFunctionReturnType: TypeScript query function ${functionName} must have a return type`);
    }

    // TODO this might be repeat code
    if (tsc.isTypeReferenceNode(functionDeclaration.type)) {
        const typeReferenceNode = functionDeclaration.type as tsc.TypeReferenceNode;
        
        if (
            tsc.isIdentifier(typeReferenceNode.typeName) &&
            typeReferenceNode.typeName.escapedText === icFunctionType &&
            typeReferenceNode.typeArguments !== undefined &&
            typeReferenceNode.typeArguments.length === 1
        ) {
            const typeArgument = typeReferenceNode.typeArguments[0];

            if (typeArgument.kind === tsc.SyntaxKind.StringKeyword) {
                return 'String';
            }
        
            if (typeArgument.kind === tsc.SyntaxKind.BooleanKeyword) {
                return 'bool';
            }

            if (
                tsc.isTypeReferenceNode(typeArgument) &&
                tsc.isIdentifier(typeArgument.typeName)
            ) {
                const functionReturnType = rustTypes[typeArgument.typeName.escapedText as string];
        
                if (functionReturnType !== undefined) {
                    return functionReturnType;
                }
                else {
                    // TODO figure this out better
                    return typeArgument.typeName.escapedText;
                }
            }

            console.log('typeArgument', typeArgument);
        }
    }

    throw new Error(`Azle::compile::getFunctionReturnType: TypeScript query function ${functionName} return type not supported`);
}

function getRustCandidStructFields(typeAliasDeclaration: tsc.TypeAliasDeclaration): ReadonlyArray<RustProperty> {
    if (tsc.isTypeReferenceNode(typeAliasDeclaration.type)) {
        const typeReferenceNode = typeAliasDeclaration.type;

        if(
            typeReferenceNode.typeArguments?.length === 1 &&
            tsc.isTypeLiteralNode(typeReferenceNode.typeArguments[0])
        ) {
            const typeLiteralNode = typeReferenceNode.typeArguments[0];

            return typeLiteralNode.members.map((member) => {
                if (tsc.isPropertySignature(member)) {
                    if (member.questionToken === undefined) {
                        return {
                            name: member.name.escapedText,
                            type: transformTypeNodeToRustType(member.type) // TODO combine this function code with the get function return type code I think
                        };
                    }
                    else {
                        return {
                            name: member.name.escapedText,
                            type: `Option<${transformTypeNodeToRustType(member.type)}>` // TODO combine this function code with the get function return type code I think
                        };
                    }
                }

                throw new Error('wrong');
            });
        }
    }
    
    return [];
}

function stringifyRustCandidStructFields(rustCandidStructFields: ReadonlyArray<RustProperty>): string {
    return rustCandidStructFields.map((rustCandidStructField) => {
        return `${rustCandidStructField.name}: ${rustCandidStructField.type}`;
    }).join(', ');
}

function getFunctionParameters(functionDeclaration: tsc.FunctionDeclaration): ReadonlyArray<RustProperty> {
    return functionDeclaration.parameters.map((parameter) => {
        if (
            tsc.isIdentifier(parameter.name) &&
            parameter.type !== undefined
            // &&
            // tsc.isTypeReferenceNode(parameter.type)
        ) {
            const parameterName = parameter.name.escapedText.toString();
            // const rustType = transformTypeReferenceNodeToRustType(parameter.type);
            const rustType = transformTypeNodeToRustType(parameter.type);
            
            return {
                name: parameterName,
                type: rustType
            };
        }
        
        throw new Error();
    });
}

function stringifyFunctionParameters(functionParameters: ReadonlyArray<RustProperty>): string {
    return functionParameters.map((functionParameter) => {
        return `${functionParameter.name}: ${functionParameter.type}`;
    }).join(', ');
}

// TODO here is where I think we want to follow aliases
function transformTypeNodeToRustType(typeNode: tsc.TypeNode): RustType {
    if (typeNode.kind === tsc.SyntaxKind.StringKeyword) {
        return 'String';
    }

    if (typeNode.kind === tsc.SyntaxKind.BooleanKeyword) {
        return 'bool';
    }

    if (
        tsc.isLiteralTypeNode(typeNode) &&
        typeNode.literal.kind === tsc.SyntaxKind.NullKeyword
    ) {
        return 'None';
    }

    if (
        tsc.isTypeReferenceNode(typeNode) &&
        tsc.isIdentifier(typeNode.typeName)
    ) {
        const rustType = rustTypes[typeNode.typeName.escapedText as string];

        if (rustType !== undefined) {
            return rustType;
        }
        else {
            return typeNode.typeName.escapedText;
        }
    }

    if (tsc.isArrayTypeNode(typeNode)) {
        if (typeNode.elementType.kind === tsc.SyntaxKind.StringKeyword) {
            return `Vec<String>`;
        }

        if (
            tsc.isTypeReferenceNode(typeNode.elementType) &&
            tsc.isIdentifier(typeNode.elementType.typeName)
        ) {
            return `Vec<${typeNode.elementType.typeName.escapedText}>`;
        }
    }

    throw new Error('TypeScript type not supported');
}